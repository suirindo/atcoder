# # 項目：マス目問題
# # 目標：マス目問題について入力を二次元配列として受取できるようになる
# # あるマスから上下左右に向かって行う処理を実装することができるようになる

# 実装は以下の手順で行う
# １：与えられた文字列を二次元配列として受け取る
# ２：マス（X,Y）から上下左右方向へ壁に当たるまで進み、
# それぞれの方向について見えるマス（＝壁に当たるまでに通ったマス）の個数をカウントする
# ３：マス（X,Y)自身の分を見えるマスのカウントに足す
# ４：見えるマスのカウント数を出力する

# 実装
# 入力を受けとる
H,W,X,Y = map(int, input().split())
# １：与えられた文字列を二次元配列として受け取る
# 地図の情報を二次元座標として受け取る
# 最終的には、
# grid [行番号] [列番号]
# でマス（行番号、列番号）が空白(=".") か障害物(="#")かを確認できるようにしたい
# 入力と障害、空白の情報をgridという二次元配列に格納する

# まずgridという空のリストを作る
grid=[]

# 次にS1〜SHを受け取る
for i in range(H):
    S = input()
    S = list(S)
    grid.append(S)


# SはH個あるのでH回のループを回す。
# さらにSをリストに分解するため、S=list（S)と書く
# これをgridに追加することで二次元配列を作ることができる

#X=1,Y=1のとき、マス(1,1)はgrid[0][0]に相当するため、
# あらかじめX,Yを−1しておく
X -= 1
Y -= 1

# ２：マス（X,Y）から上下左右方向へ壁に当たるまで進み、
# それぞれの方向について見えるマス（＝壁に当たるまでに通ったマス）の個数をカウントする
# 見えるマスの個数を格納する変数をansとしておく
ans = 0

# まず上向きから確認する
# マス（X,Y)から順に上方向にマスをみていくということはマス(X-1, Y), (X-2, Y), (X-3, Y)。。。を確認していくということ
# for文でi=1,2,3...についてgrid[X-1][Y]を順に確認していけばいい

# 上
for i in range(1,H):
    if 0<=X-i<H:
        if grid[X-i][Y] =="#":
            break
        else:
            ans +=1

# 下
for i in range(1,H):
    if 0<=X+i<H:
        if grid[X+i][Y] =="#":
            break
        else:
            ans +=1


# 左
for i in range(1,W):
    if 0<=Y-i<W:
        if grid[X][Y-i] =="#":
            break
        else:
            ans +=1

# 右
for i in range(1,W):
    if 0<=Y+i<W:
        if grid[X][Y+i] =="#":
            break
        else:
            ans +=1
ans +=1
print(ans)